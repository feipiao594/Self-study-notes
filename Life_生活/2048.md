---
title: 2048
mathjax: false
categories:
  - Life_生活
abbrlink: cc2541cf
date: 2025-12-06 20:23:35
---

# 2048

小游戏，测试流畅性，同时学习 vibe coding

<!--more-->

唉唉，我是对 2048 有一些执念的，vibe coding 做这个真的快

## 游戏说明

这是一个经典的 2048 数字拼图游戏。

### 玩法：
- 对于 PC 端，使用键盘方向键或 WASD 键(需点击一下棋盘让焦点位于游戏内)
- 对于手机端，点击屏幕上的方向按钮来移动所有方块。
- 相同数字的方块相撞时会合并为更大的数字。
- 每次移动，都会在棋盘上任意一个格子生成 2(90%) 或 4(10%)
- 目标是得到 2048 方块，但你可以继续玩更高分数。
- 当格子填满且无法移动时游戏结束。

### 特色：
- 支持在第一次移动后进行缓存，刷新页面后可继续上次游戏。
- 达到 2048 后可继续挑战更高分数。
- 支持 PC 和移动端。

### 分数计算公式

每次合并两个相同数字的方块时，分数会增加合并后的数值。例如：

- 两个 2 合并为 4，得 4 分
- 两个 4 合并为 8，得 8 分
- 两个 8 合并为 16，得 16 分

以此类推。


## 游戏本体

<div id="game-container" tabindex="0">
  <div id="game-section">
    <div id="score">分数: <span id="score-value">0</span> <span id="status"></span></div>
    <div id="grid"></div>
  </div>
  <div id="controls">
    <div id="direction-buttons">
      <button id="up">↑</button>
      <button id="left">←</button>
      <button id="right">→</button>
      <button id="down">↓</button>
    </div>
    <button id="restart">重新开始</button>
  </div>
</div>

<style>
#game-container {
  max-width: 600px;
  margin: 0 auto;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#game-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#score {
  text-align: center;
  font-size: min(24px, 6vw);
  margin-bottom: 10px;
}

#status {
  font-size: min(16px, 4vw);
  color: #776e65;
  margin-left: 20px;
}

#grid {
  position: relative;
  width: min(400px, 90vw);
  height: min(400px, 90vw);
  background-color: #bbada0;
  border-radius: 6px;
}

.cell {
  position: absolute;
  width: 22%;
  height: 22%;
  background-color: #cdc1b4;
  border-radius: 3px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: min(36px, 9vw);
  font-weight: bold;
  color: #776e65;
  transition: left 0.2s ease, top 0.2s ease, transform 0.1s ease;
}

.cell[data-value="128"], .cell[data-value="256"], .cell[data-value="512"] { font-size: min(28px, 7vw); }
.cell[data-value="1024"], .cell[data-value="2048"] { font-size: min(24px, 6vw); }
.cell[data-value="4096"], .cell[data-value="8192"] { font-size: min(24px, 5vw); }
.cell[data-value="16384"], .cell[data-value="32768"] { font-size: min(22px, 4vw); }
.cell[data-value="65536"], .cell[data-value="131072"] { font-size: min(20px, 3.5vw); }

.cell[data-value="2"] { background-color: #eee4da; }
.cell[data-value="4"] { background-color: #ede0c8; }
.cell[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
.cell[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
.cell[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
.cell[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
.cell[data-value="128"] { background-color: #edcf72; color: #f9f6f2; }
.cell[data-value="256"] { background-color: #edcc61; color: #f9f6f2; }
.cell[data-value="512"] { background-color: #edc850; color: #f9f6f2; }
.cell[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; }
.cell[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; }
.cell[data-value="4096"] { background-color: #3c3a32; color: #f9f6f2; }
.cell[data-value="8192"] { background-color: #2e2b24; color: #f9f6f2; }
.cell[data-value="16384"] { background-color: #1e1c16; color: #f9f6f2; }
.cell[data-value="32768"] { background-color: #0f0e0a; color: #f9f6f2; }
.cell[data-value="65536"] { background-color: #000000; color: #f9f6f2; }
.cell[data-value="131072"] { background-color: #000000; color: #f9f6f2; }

#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px 0;
}

#direction-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-rows: 1fr 1fr 1fr;
  gap: min(10px, 2.5vw);
  width: min(150px, 37.5vw);
  height: min(150px, 37.5vw);
}

#up { grid-column: 2; grid-row: 1; }
#left { grid-column: 1; grid-row: 2; }
#right { grid-column: 3; grid-row: 2; }
#down { grid-column: 2; grid-row: 3; }

button {
  font-size: min(24px, 6vw);
  padding: min(10px, 2.5vw);
  border: none;
  border-radius: 5px;
  background-color: #8f7a66;
  color: white;
  cursor: pointer;
}

button:hover {
  background-color: #9f8a76;
}

#restart {
  margin-top: 20px;
}

/* PC端：横向布局，controls在右侧 */
@media (min-width: 768px) {
  #game-container {
    flex-direction: row;
    justify-content: center;
    align-items: center;
  }

  #controls {
    margin: 0 0 0 50px;
  }
}

.cell.new {
  animation: appear 0.2s ease-out;
}

@keyframes appear {
  0% { transform: scale(0); }
  100% { transform: scale(1); }
}
</style>

<script>
let grid = [];
let score = 0;
let newTiles = [];
let mergedTiles = [];
let animating = false;
let hasWon = false;

function saveGame() {
  const gameState = {
    grid: grid,
    score: score,
    hasWon: hasWon
  };
  localStorage.setItem('game2048', JSON.stringify(gameState));
}

function loadGame() {
  const saved = localStorage.getItem('game2048');
  if (saved) {
    const gameState = JSON.parse(saved);
    grid = gameState.grid;
    score = gameState.score;
    hasWon = gameState.hasWon;
    return true;
  }
  return false;
}

function initGrid() {
  document.getElementById('grid').innerHTML = '';
  let loaded = loadGame();
  if (!loaded) {
    grid = Array(4).fill().map(() => Array(4).fill(0));
    score = 0;
    hasWon = false;
    addRandomTile();
    addRandomTile();
  }
  updateScore();
  if (loaded) {
    if (hasWon) {
      updateStatus('已获胜，可继续');
    } else if (isGameOver()) {
      updateStatus('游戏结束，请重新开始');
    } else {
      updateStatus('');
    }
  } else {
    updateStatus('');
  }
  renderGrid();
}

function addRandomTile() {
  let emptyCells = [];
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 0) {
        emptyCells.push({x: i, y: j});
      }
    }
  }
  if (emptyCells.length > 0) {
    let randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
    grid[randomCell.x][randomCell.y] = Math.random() < 0.9 ? 2 : 4;
    newTiles.push({x: randomCell.x, y: randomCell.y});
  }
}

function renderGrid() {
  const gridElement = document.getElementById('grid');
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      let id = 'cell-' + i + '-' + j;
      let cell = document.getElementById(id);
      if (!cell) {
        cell = document.createElement('div');
        cell.id = id;
        cell.className = 'cell';
        gridElement.appendChild(cell);
      }
      cell.style.left = (j * 25 + 1.5) + '%';
      cell.style.top = (i * 25 + 1.5) + '%';
      cell.setAttribute('data-value', grid[i][j]);
      cell.textContent = grid[i][j] !== 0 ? grid[i][j] : '';
      cell.classList.remove('new', 'merged');
      // 检查是否是新出现的块
      if (newTiles.some(tile => tile.x === i && tile.y === j)) {
        cell.classList.add('new');
      }
      // 检查是否是合并的块
      if (mergedTiles.some(tile => tile.x === i && tile.y === j)) {
        cell.classList.add('merged');
      }
    }
  }
  // 清空动画标记
  setTimeout(() => {
    newTiles = [];
    mergedTiles = [];
  }, 200);
}

function updateScore() {
  document.getElementById('score-value').textContent = score;
}

function updateStatus(message) {
  document.getElementById('status').innerHTML = message;
}

function slideAndMerge(array, rowIndex, direction) {
  let filtered = array.filter(val => val !== 0);
  let newArray = [];
  let merged = false;
  for (let val of filtered) {
    if (newArray.length > 0 && newArray[newArray.length - 1] === val && !merged) {
      newArray[newArray.length - 1] *= 2;
      score += newArray[newArray.length - 1];
      let pos;
      if (direction === 'left') {
        pos = {x: rowIndex, y: newArray.length - 1};
      } else if (direction === 'right') {
        pos = {x: rowIndex, y: 3 - (newArray.length - 1)};
      } else if (direction === 'up') {
        pos = {x: newArray.length - 1, y: rowIndex};
      } else if (direction === 'down') {
        pos = {x: 3 - (newArray.length - 1), y: rowIndex};
      }
      mergedTiles.push(pos);
      merged = true;
    } else {
      newArray.push(val);
      merged = false;
    }
  }
  while (newArray.length < 4) newArray.push(0);
  return newArray;
}

function move(direction) {
  // 停止之前的动画
  document.querySelectorAll('.cell.new, .cell.merged').forEach(cell => {
    cell.classList.remove('new', 'merged');
  });
  newTiles = [];
  mergedTiles = [];
  let originalGrid = JSON.parse(JSON.stringify(grid));
  let newGrid = JSON.parse(JSON.stringify(grid));
  let moved = false;

  switch(direction) {
    case 'left':
      for (let i = 0; i < 4; i++) {
        newGrid[i] = slideAndMerge(newGrid[i], i, 'left');
      }
      break;
    case 'right':
      for (let i = 0; i < 4; i++) {
        newGrid[i].reverse();
        newGrid[i] = slideAndMerge(newGrid[i], i, 'right');
        newGrid[i].reverse();
      }
      break;
    case 'up':
      for (let j = 0; j < 4; j++) {
        let col = [];
        for (let i = 0; i < 4; i++) col.push(newGrid[i][j]);
        col = slideAndMerge(col, j, 'up');
        for (let i = 0; i < 4; i++) newGrid[i][j] = col[i];
      }
      break;
    case 'down':
      for (let j = 0; j < 4; j++) {
        let col = [];
        for (let i = 0; i < 4; i++) col.push(newGrid[i][j]);
        col.reverse();
        col = slideAndMerge(col, j, 'down');
        col.reverse();
        for (let i = 0; i < 4; i++) newGrid[i][j] = col[i];
      }
      break;
  }

  if (JSON.stringify(originalGrid) !== JSON.stringify(newGrid)) {
    moved = true;
  }

  if (moved) {
    grid = newGrid;
    addRandomTile();
    renderGrid();
    updateScore();
    saveGame();
    if (checkWin() && !hasWon) {
      hasWon = true;
      animating = true;
      setTimeout(() => {
        updateStatus('已获胜，可继续');
        alert('恭喜！你达到了2048！分数：' + score);
        animating = false;
      }, 200);
    } else if (isGameOver()) {
      animating = true;
      setTimeout(() => {
        updateStatus('游戏结束，请重新开始');
        alert('游戏结束！分数：' + score);
        animating = false;
      }, 200);
    }
    
  }
}

function checkWin() {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 2048) return true;
    }
  }
  return false;
}

function isGameOver() {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 0) return false;
      if (j < 3 && grid[i][j] === grid[i][j + 1]) return false;
      if (i < 3 && grid[i][j] === grid[i + 1][j]) return false;
    }
  }
  return true;
}

document.getElementById('up').addEventListener('click', () => move('up'));
document.getElementById('left').addEventListener('click', () => move('left'));
document.getElementById('right').addEventListener('click', () => move('right'));
document.getElementById('down').addEventListener('click', () => move('down'));
document.getElementById('restart').addEventListener('click', () => {
  localStorage.removeItem('game2048');
  initGrid();
});

// 键盘控制
const gameContainer = document.getElementById('game-container');
gameContainer.addEventListener('keydown', (e) => {
  const keyMap = {
    'ArrowUp': 'up',
    'ArrowLeft': 'left',
    'ArrowRight': 'right',
    'ArrowDown': 'down',
    'KeyW': 'up',
    'KeyA': 'left',
    'KeyS': 'down',
    'KeyD': 'right'
  };
  if (keyMap[e.code]) {
    e.preventDefault();
    move(keyMap[e.code]);
  }
});

initGrid();
</script>
