---
title: Git使用_第2弹
mathjax: false
categories:
  - CS_计算机
  - Project_Tools
  - Git
abbrlink: 2b9af9d8
---

# Git使用_第2弹
接下来正式进入Git的使用部分，这一弹从`"Git Pro"`的第二章开始

<!--more-->
## 在已存在目录中初始化仓库
如果你有一个尚未进行版本控制的项目目录，想要用Git来控制它，那么首先需要进入该项目目录中。 
```shell
$ git init
```
该命令将创建一个名为`.git`的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。

如果在一个已存在文件的文件夹(而非空文件夹)中进行版本控制，你应该开始追踪这些文件并进行初始提交。可以通过`git add`命令来指定所需的文件来进行追踪，然后执行`git commit`：

```shell
$ git add *.c
$ git add LICENSE
$ git commit -m 'initial project version'
```

---

## 克隆现有的仓库
如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到`git clone`命令。 
克隆仓库的命令是`git clone <url>`。比如，要克隆该博客的markdown文件夹，可以用下面的命令：
```shell
$ git clone https://github.com/feipiao594/Self-study-notes.git
```
这会在当前目录下创建一个名为`"Self-study-notes"` 的目录，并在这个目录下初始化一个`.git`文件夹， 从远程仓库拉取下所有数据放入`.git`文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。
如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：
```shell
$ git clone https://github.com/feipiao594/Self-study-notes.git dailyNotes
```
这会执行与上一条命令相同的操作，但目标目录名变为了`dailyNotes`。
Git 支持多种数据传输协议。 上面的例子使用的是 `https://`协议，不过你也可以使用`git://`协议或者使用
SSH传输协议，比如`user@server:path/to/repo.git`。我们会`"在服务器上搭建Git"`将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。

---

## 记录每次更新到仓库
现在我们的机器上有了一个真实项目的Git仓库，并从这个仓库中检出了所有文件的工作副本。通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到仓库。
请记住，你工作目录下的每一个文件都不外乎这两种状态：**已跟踪**或**未跟踪**。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是Git已经知道的文件。
工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为Git刚刚检出了它们，而你尚未编辑过它们。
编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git将它们标记为已修改文件。在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。
下图展示了文件的状态变化周期
<img src="/images/Git使用_第二弹_图1.png" width="100%" height="100%">

## 一些基本操作
下面是一些基本的操作
### 检查当前文件状态
可以用`git status`命令查看哪些文件处于什么状态。

### 跟踪新文件
使用命令`git add`开始跟踪一个文件。所以，要跟踪`README`文件，运行：
```shell
$ git add README
```

此时再运行`git status`命令，会看到`README`文件已被跟踪，并处于暂存状态：
```shell
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
   new file: README
```

只要在`Changes to be committed`这行下面的，就说明是已暂存状态。如果此时提交，那么该文件在你运
行`git add`时的版本将被留存在后续的历史记录中。`git add`命令使用**文件或目录的路径**作为参数；如果参数是**目录的路径**，该命令将**递归**地跟踪该目录下的**所有文件**。

### 暂存已修改的文件
如果你修改了一个名为`CONTRIBUTING.md`的已被跟踪的文件，然后运行`git status`命令,，此时文件`CONTRIBUTING.md`出现在`Changes not staged for commit`这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行`git add`命令。
>注意`git add`这是个多功能命令：可以用它开始**跟踪新文件**，或者把**已跟踪**的文件放到**暂存区**，还能用于**合并时把**有**冲突**的文件**标记**为**已解决**状态等。

如果你运行`git add`命令后再一次修改`CONTRIBUTING.md`文件，你就会发现现在 `CONTRIBUTING.md`文件同时出现在暂存区和非暂存区。

### 状态简览
可以在`git status`后面添加`-s`或者`--short`参数即使用`git status -s`命令或`git status --short`命令，你将得到一种格式更为紧凑的输出。
```bash
$ git status -s
  M README
  MM Rakefile
  A lib/git.rb
  M lib/simplegit.rb
  ?? LICENSE.txt
```
新添加的未跟踪文件前面有`??`标记，新添加到暂存区中的文件前面有`A`标记，修改过的文件前面有`M`标记。输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示：`README`文件在工作区已修改但尚未暂存，而 `lib/simplegit.rb`文件已修改且已暂存。`Rakefile`文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。

### 忽略文件
一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以在项目根目录下创建一个名为`.gitignore`的文件，列出要忽略的文件的模式。 
要养成一开始就为你的新仓库设置好`.gitignore`文件的习惯，以免将来误提交这类无用的文件。
文件`.gitignore`的格式规范如下：
- 所有空行或者以`#`开头的行都会被Git忽略。
- 可以使用标准的**glob模式匹配**，它会递归地应用在整个工作区中。
- 匹配模式可以以`(/)`开头防止递归。
- 匹配模式可以以`(/)`结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号`(!)`取反。
  
所谓的glob模式是指**shell**所使用的**简化了的正则表达式**。 星号`(*)`匹配零个或多个任意字符；`[abc]`匹配
任何一个列在方括号中的字符 (这个例子要么匹配一个a，要么匹配一个b，要么匹配一个 c)； 问号`(?)`只
匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配
(比如`[0-9]`表示匹配所有0到9的数字)。 使用两个星号`(**)`表示匹配任意中间目录，比如 `a/**/z`可以匹配`a/z`、`a/b/z`或`a/b/c/z`等。

### 查看已暂存和未暂存的修改

想知道具体修改了什么地方，可以用`git diff`命令。 稍后我们会详细介绍`git diff`，你通常可能会用它来回答这两个问题：**当前做的哪些更新尚未暂存？有哪些更新已暂存并准备好下次提交**？ 虽然 `git status`已经通过在相应栏下列出文件名的方式回答了这个问题，但`git diff`能通过文件补丁的格式更加具体地显示哪些行发生了改变。

不加参数直接输入`git diff`可以比较工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。
若要查看已暂存的将要添加到下次提交里的内容，可以用`git diff --staged`命令。 这条命令将比对已暂存文件与最后一次提交的文件差异

请注意，`git diff`本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行`git diff`后却什么也没有，就是这个原因。

用`git diff --cached`查看已经暂存起来的变化(`--staged`和`--cached`是同义词)

### 提交更新
现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有`git add`过，否则提交的时候不会记录这些尚未暂存的变化。这些已修改但未暂存的文件只会保留在本地磁盘。所以，每次准备提交前，先用`git status`看下，你所需要的文件是不是都已暂存起来了，然后再运行提交命令
```shell
$ git commit
```
这样会启动你选择的文本编辑器(在很多IDE中，通常是vim)来输入提交说明。
你也可以在`commit`命令后添加`-m`选项，将提交信息与命令放在同一行

### 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给`git commit`加上`-a`选项，Git就会自动把**所有已经跟踪过**的文件**暂存**起来**一并提交**，从而跳过`git add`步骤

### 移除文件
要从Git中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提交。
可以用`git rm`命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

