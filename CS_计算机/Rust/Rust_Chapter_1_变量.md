---
title: Rust_Chapter_1_变量
mathjax: false
categories:
- CS_计算机
- Rust
---


# Rust_Chapter_1_变量
这一章节内容主要是Rust的变量

<!--more-->

## 前言
从现在开始，我正式开始学习Rust。Rust相对于C++在出于安全的**规范优势**不必多说，我发现Rust也能用于嵌入式开发。
因而我受够了，**快用Rust重写**(乐)
在写这一章的时候，我手头看的这一本书是《Rust权威指南》，虽说序论中说并不适合新手，但是就我读了前三章似乎也没有遇见特别难懂的概念。

## Hello Rust
新学一门编程语言，肯定少不了Hello_World，基本礼仪
```rust
fn main(){
    println!("Hello Rust!");
}
```
简简单单的一行，与C++类似
`fn main()`是main函数的声明，入口函数就是`main()`函数，没什么好说的
`println!()`是一个宏而非函数，这点在后面在解释
`println!()`可以使用类似C++20`std::format`的语法形式，具体如下
```rust
println!("{1} learn rust {0}",666,"feipiao");
//输出结果 feipiao learn rust 666
```
## 变量
```rust
fn main(){
    let x = 666;
    let mut y = 233;
}
```
首先，Rust中的变量默认是**不可变变量**，也就是`let x = 666;`，这和C++有很大的不同，我想不出C++有什么平替，因为它并不是C++中加`const`的那种常量，C/C++中的变量其实都是第二条`let mut y = 233;`，为**可变变量**
还记得C/C++有一个`mutable`关键字么，这里的`mut`其实就是它的缩写
那么他俩有什么区别呢

### 不可变变量
不可变变量保证了数据不会被修改，例如运行如下的错误代码会报错
```rust
fn main(){
    let x = 666;
    x = 100;//这是会报错滴
}
```
而以下代码就不会报错，因为这里`666`是利用`let`被**隐藏/shadow**了，我们可以重复使用`let`关键字并配以相同的名称来不断地**隐藏**变量
```rust
fn main(){
    let x = 666;
    let x = 100;//666被隐藏了，x代表100，这保证了666这个数据没有被修改
}
```
值得一提的是，这种shadow甚至可以改变x的类型，也就是说除了x的名字没变，它这个名字代表的本身是什么完全可以变掉
也就是说，把一个人的名字给了另一个人，这个人也就自然被隐藏起来了，但谁也还是自己，**没被修改**不是么
个人感觉这和**C/C++作用域下名称的覆盖**类似，也许那也是一种shadow呢？
### 可变变量
像可变变量就很类似C/C++了，其在第一次声明的时候类型就已经被确定了
```rust
fn main(){
    let mut x = 666;
    x = 233;
}
```
这里声明了x是一个可变变量，第二句就修改了它的值，但**x的类型**在第一句的时候就已经被**确认**是一个整型了(下面会讲到，这里是**自动类型推导**)，如果在这个时候把第二句改成`x = 233.2`就会报错

### let即隐藏&可变与不可变的底层内涵
```rust
fn main() {
    let a = 233;
    println!("{}", a);
    let mut a = 233;
    println!("{}", a);
    a = 666;
    println!("{}", a);
}
//正确编译，结果如下
//233
//233
//666
```
注意`let`代表的就是shadow的含义，既然是隐藏，那么意味着类型可以被更改，也就是说第二个`let mut a = 233;`时a就变成了一个可变变量了，但原来上面第一个的`let a = 233`中233还存在于栈上，并**没有被改变**，只是a不再能访问到它了而已。第三句由于a已经是一个可变变量了，自然也是成立的

可以看看如下**缩减的汇编码**，本篇文档记录时使用的环境为`rustc 1.69.0 (84c898d65 2023-04-16)`
上述代码经过`rustc -O --emit asm=main.s .\main.rs`生成的完整的汇编文件[github仓库链接]()
```nasm
_ZN4main4main17hd0d97daef3a32cf2E:
...
movl	$233, 36(%rsp)
...
callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E
...
movl	$233, 32(%rsp)
...
callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E、
...
movl	$666, 32(%rsp)
...
callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E
```
可以清晰的看到rust所承诺的**不可变变量的不可被修改性**，也可以看到**可变变量在原位被更改**

### 变量的类型
Rust是一个强类型的语言，但从上面的例子好像看不出来，因为它存在有自动的类型推导