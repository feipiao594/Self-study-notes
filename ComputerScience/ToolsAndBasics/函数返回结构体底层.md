---
title: 函数返回结构体底层
mathjax: false
categories:
- ComputerScience
- ToolsAndBasics
---


# 函数如何返回一个结构体
结构体如何返回时编译器相关的未定义行为，但是有时候研究它也是有一定用途的

<!--more-->

## 实验代码

```C
#include <stdio.h>
typedef struct student
{
    int a;
    char b[4];
} stu;

stu foo(int a, char b)
{
    stu A;
    A.a = a;
    A.b[0] = b;
    return A;
}

int main(void)
{
    stu B;
    B = foo(2, 'a');
    printf("%d %c\n", B.a, B.b[0]);
    return 0;
}
```

## 结果

`gcc -Og -o`选项编译, 反汇编得到的结果如下:

```aw
   0x0000000000001149 <+0>:     endbr64 
   0x000000000000114d <+4>:     movzbl %sil,%esi  // sil ---> esi
   0x0000000000001151 <+8>:     shl    $0x20,%rsi // rsi <<= 32 0x61 ---> 0x6100000000
   0x0000000000001155 <+12>:    mov    %edi,%eax  // eax = 0x2
   0x0000000000001157 <+14>:    or     %rsi,%rax  // RAX  0x6100000002
   0x000000000000115a <+17>:    ret    
```

```aw
   0x000000000000115b <+0>:     endbr64 
   0x000000000000115f <+4>:     sub    $0x8,%rsp
   0x0000000000001163 <+8>:     mov    $0x61,%esi // 97 ascii 'a' in esi ---> 1st argument
   0x0000000000001168 <+13>:    mov    $0x2,%edi  // 2 in edi ---> 2nd argument
   0x000000000000116d <+18>:    call   0x1149 <foo>
   0x0000000000001172 <+23>:    mov    %rax,%rcx  // returned val rax ---> rcx ---> 3rd argument
   // <__do_global_dtors_aux_fini_array_entry>
   0x0000000000001175 <+26>:    shl    $0x18,%rcx // rcx <<= 24 ---> 0x61 00 00 00 02 00 00 00
   0x0000000000001179 <+30>:    sar    $0x38,%rcx // rcx >>= 56 ---> 0x61 (注意是算术右移)
   0x000000000000117d <+34>:    mov    %eax,%edx  // eax ---> edx ---> 0x2
   0x000000000000117f <+36>:    lea    0xe7e(%rip),%rsi        # 0x2004
   0x0000000000001186 <+43>:    mov    $0x1,%edi  // edi = 2
   0x000000000000118b <+48>:    mov    $0x0,%eax  // eax = 0
   0x0000000000001190 <+53>:    call   0x1050 <__printf_chk@plt>
   0x0000000000001195 <+58>:    mov    $0x0,%eax
   0x000000000000119a <+63>:    add    $0x8,%rsp
   0x000000000000119e <+67>:    ret    
```

注意看这里的`rax`返回的是`0x6100000002`, 在同一个寄存器里存储了字符`a`和一个`2`. 在`main`函数里又通过复制-移位操作让`rcx`的高4个字节储存的`a`, 低4个字节储存的`2`(我的电脑是小端法表示).

为了探究这种编译方式是否是`gcc`编译器独有的, 我在`clang`下编译了相同的代码, 结果如下:

```aw
   0x0000000000401130 <+0>:     push   %rbp         // store rbp
   0x0000000000401131 <+1>:     mov    %rsp,%rbp    // rbp = rsp
   0x0000000000401134 <+4>:     mov    %sil,%al     
   0x0000000000401137 <+7>:     mov    %edi,-0xc(%rbp) // edi stored in -0xc
   0x000000000040113a <+10>:    mov    %al,-0xd(%rbp)  // al stored in -0xd 
   0x000000000040113d <+13>:    mov    -0xc(%rbp),%eax // move -0xc in eax
   0x0000000000401140 <+16>:    mov    %eax,-0x8(%rbp) // eax stored in -0x8
   0x0000000000401143 <+19>:    mov    -0xd(%rbp),%al  // -0xd stored in al
   0x0000000000401146 <+22>:    mov    %al,-0x4(%rbp)  // al stored in -4
   0x0000000000401149 <+25>:    mov    -0x8(%rbp),%rax // -0x8 stored in rax
   0x000000000040114d <+29>:    pop    %rbp
   0x000000000040114e <+30>:    ret   
```

注意看, 栈上确实临时创建了一个结构体, 但这里的行为和`gcc`本质上还是一样的, 只不过`clang`更贴近C语言: 赋值给结构体的成员, 然后又把这个值赋给不同操作数大小的`rax`, 最后返回的还是`rax`.

```aw
   0x0000000000401150 <+0>:     push   %rbp
   0x0000000000401151 <+1>:     mov    %rsp,%rbp
   0x0000000000401154 <+4>:     sub    $0x20,%rsp
   0x0000000000401158 <+8>:     movl   $0x0,-0x4(%rbp)
   0x000000000040115f <+15>:    mov    $0x2,%edi
   0x0000000000401164 <+20>:    mov    $0x61,%esi
   0x0000000000401169 <+25>:    call   0x401130 <foo>
   0x000000000040116e <+30>:    mov    %rax,-0x18(%rbp)
   0x0000000000401172 <+34>:    mov    -0x18(%rbp),%rax
   0x0000000000401176 <+38>:    mov    %rax,-0x10(%rbp)
   0x000000000040117a <+42>:    mov    -0x10(%rbp),%esi
   0x000000000040117d <+45>:    movsbl -0xc(%rbp),%edx
   0x0000000000401181 <+49>:    movabs $0x402004,%rdi
   0x000000000040118b <+59>:    mov    $0x0,%al
   0x000000000040118d <+61>:    call   0x401030 <printf@plt>
   0x0000000000401192 <+66>:    xor    %eax,%eax
   0x0000000000401194 <+68>:    add    $0x20,%rsp
   0x0000000000401198 <+72>:    pop    %rbp
   0x0000000000401199 <+73>:    ret    
```

可以看到`gcc`编译器为了效率最大化, 会采用一种看起来非常奇怪的方式编译: 能用寄存器解决的问题, 绝对不用内存, 并将冗余的操作剔除. 在上面的实验中, 数据量很少. 我们来印证下再添加一个变量是否依然满足这一点:

修改一下上面的实验代码:

```C
stu foo(int a, char b, char c)
{
    stu A;
    A.a = a;
    A.b[0] = b;
    A.b[1] = c;
    return A;
}
B = foo(2, 'a', 'b');
```

编译选项: `gcc -Og -o`

```aw
   0x0000000000001149 <+0>:     endbr64 
   0x000000000000114d <+4>:     movzbl %sil,%esi  // 0x61
   0x0000000000001151 <+8>:     shl    $0x20,%rsi // ---> 0x6100000000
   0x0000000000001155 <+12>:    mov    %edi,%edi  // ?
   0x0000000000001157 <+14>:    movzbl %dl,%edx
   0x000000000000115a <+17>:    shl    $0x28,%rdx // 0x62 ---> 0x620000000000
   0x000000000000115e <+21>:    or     %rsi,%rdi  // ---> 0x6100000002
   0x0000000000001161 <+24>:    mov    %rdi,%rax  // ---> 0x6100000002
   0x0000000000001164 <+27>:    or     %rdx,%rax  // ---> 0x626100000002
   0x0000000000001167 <+30>:    ret  
```

可以发现`foo`函数还是采取类似的策略, 看起来`rax`还能装得下`A`. 下面, 我们再次修改实验代码, 尝试拷贝一个字符串:

```C
#include <stdio.h>
#include <string.h>
typedef struct student
{
    int a;
    char b[12];
} stu;

stu foo(int a, char b[12])
{
    stu A;
    A.a = a;
    strcpy(A.b, b);
    return A;
}

int main(void)
{
    stu B;
    char *str = "hello world";
    B = foo(2, str);
    printf("%d %s\n", B.a, B.b);
    return 0;
}
```

编译选项为: `gcc -fno-stack-protector -Og -o`

```aw
   0x0000000000001169 <+0>:     endbr64 
   0x000000000000116d <+4>:     sub    $0x38,%rsp       // allocate stack frame
   0x0000000000001171 <+8>:     mov    %edi,0x10(%rsp)  
   0x0000000000001175 <+12>:    lea    0x14(%rsp),%rdi
   // rdi: 0x7fffffffdbb4 ◂— 0x100000000007fff
   0x000000000000117a <+17>:    mov    $0xc,%edx        // string length 12
   0x000000000000117f <+22>:    call   0x1060 <__strcpy_chk@plt>
        // dest: 0x7fffffffdbb4 ◂— 0x100000000007fff
        // src: 0x555555556004 ◂— 'hello world'
        // destlen: 0xc
    // after strcpy():
    // *RAX  0x7fffffffdbb4 ◂— 'hello world'
    // *RCX  0x646c726f77206f
    // *RSI  0x6f77206f6c6c6568 ('hello wo')
    // pwndbg> x/8gx $rsp
    // 0x7fffffffdba0: 0x00000000000006f0      0x00007fffffffdf99
    //*0x7fffffffdbb0: 0x6c6c656800000002      0x00646c726f77206f ◂— changed
    // 0x7fffffffdbc0: 0x0000000000000002      0x00000000178bfbff
    // 0x7fffffffdbd0: 0x00007fffffffdfa9      0x00005555555551b6
   0x0000000000001184 <+27>:    mov    0x10(%rsp),%rax  // rax = 0x6c6c656800000002
   0x0000000000001189 <+32>:    mov    0x18(%rsp),%rdx  // rdx = rcx = 0x646c726f77206f
   0x000000000000118e <+37>:    mov    %rax,0x20(%rsp)  
   0x0000000000001193 <+42>:    mov    %rdx,0x28(%rsp)  
   0x0000000000001198 <+47>:    add    $0x38,%rsp       // restore
    // 0x5555555551b6 return address
    // pwndbg> x/8gx $rsp
    // 0x7fffffffdbd8: 0x00005555555551b6      0x0000000000001000
    // 0x7fffffffdbe8: 0x0000555555555080      0x0000000000000000
    // 0x7fffffffdbf8: 0x00007ffff7db0d90      0x0000000000000000
    // 0x7fffffffdc08: 0x000055555555519d      0x00000001ffffdcf0
   0x000000000000119c <+51>:    ret    
```

你会发现`rax`和`rdx`的值存储在栈上, 但最后因为恢复栈了以后值就消失了. 也就表明, 结构体临时变量消失了. 这很合理.
而我们返回的值, 就是`rax`和`rdx`了.

```aw
   0x000000000000119d <+0>:     endbr64 
   0x00000000000011a1 <+4>:     sub    $0x18,%rsp
   0x00000000000011a5 <+8>:     lea    0xe58(%rip),%rsi        # 0x2004 str "hello world"
   // rsi: 0x555555556004 'hello world'
   0x00000000000011ac <+15>:    mov    $0x2,%edi
   0x00000000000011b1 <+20>:    call   0x1169 <foo>
   0x00000000000011b6 <+25>:    mov    %rax,(%rsp)      // rax stored on stack
   0x00000000000011ba <+29>:    mov    %rdx,0x8(%rsp)   // rdx stored on stack+0x8
    // 0x7fffffffdbe0: 0x6c6c656800000002      0x00646c726f77206f ◂— changed
    // 0x7fffffffdbf0: 0x0000000000000000      0x00007ffff7db0d90
    // 0x7fffffffdc00: 0x0000000000000000      0x000055555555519d
    // 0x7fffffffdc10: 0x00000001ffffdcf0      0x00007fffffffdd08
   0x00000000000011bf <+34>:    lea    0x4(%rsp),%rcx   //  rcx = 0x4 + &rsp
   // rcx: 0x7fffffffdbe4 ◂— 'hello world'
   0x00000000000011c4 <+39>:    mov    (%rsp),%edx      // edx = *rsp
   // edx: 0x2
   0x00000000000011c7 <+42>:    lea    0xe42(%rip),%rsi        # 0x2010
   0x00000000000011ce <+49>:    mov    $0x1,%edi
   0x00000000000011d3 <+54>:    mov    $0x0,%eax
   0x00000000000011d8 <+59>:    call   0x1070 <__printf_chk@plt>
   // ► 0x5555555551d8 <main+59>    callq  __printf_chk@plt                <__printf_chk@plt>
   //    flag: 0x1
   //  format: 0x555555556010 ◂— 0xa7325206425 /* '%d %s\n' */
   //  vararg: 0x2
   0x00000000000011dd <+64>:    mov    $0x0,%eax
   0x00000000000011e2 <+69>:    add    $0x18,%rsp
   0x00000000000011e6 <+73>:    ret    
```

这里`rax`为`0x6c6c656800000002`, 可以看到`6c 6c 65 68`为`l l e h`. 最后一位为`2`. `lea    0x4(%rsp),%rcx` 这一步是读取`B.b`(字符数组的首地址), `0x7fffffffdbe4`.

